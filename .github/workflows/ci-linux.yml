# This is a basic workflow to help you get started with Actions

name: CI-linux

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    runs-on: macos-latest
    env:
      CACHED_DOWNLOADS: downloads
    steps:
      - name: Checkout sources
        uses: actions/checkout@v3

      - name: Install postgres
        uses: ikalnytskyi/action-setup-postgres@v3
        id: pg

      - run: |
          # start postgresql
          brew services start postgresql
          psql -v ON_ERROR_STOP=1 -c "select version();" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "SELECT current_user;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "SELECT session_user;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "RESET ROLE;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "SELECT * FROM pg_roles;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c '\l' "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c '\l+' "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c 'show is_superuser;' "$CONNECTION_URI"

          pg_ctl -D /usr/local/var/postgres start || echo "pg_ctl failed"
          createuser -s postgres || echo "createuser failed"
          
          sudo -i -u postgres psql -v ON_ERROR_STOP=1 -c 'show is_superuser;' "$CONNECTION_URI"

          psql -v ON_ERROR_STOP=1 -c 'show is_superuser;' "$CONNECTION_URI"

        env:
          CONNECTION_URI: ${{ steps.pg.outputs.connection-uri }}

      - run: |
          brew install postgis
          # sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable
          # sudo apt-get update
          # sudo apt-cache search postgis
          # sudo apt install -y postgis

      - name: bash
        env:
          CONNECTION_URI: ${{ steps.pg.outputs.connection-uri }}
        run: |
          echo "CONNECTION_URI = $CONNECTION_URI" | base64
          set -x
          # which pg_ctl || true
          # which pg_isready || true
          # which psql || true
          # export | sort
          # sudo systemctl start postgresql.service
          # pg_isready
          psql -v ON_ERROR_STOP=1 -c "select version();" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "SELECT current_user;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "SELECT session_user;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "RESET ROLE;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c "SELECT * FROM pg_roles;" "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c '\l' "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c '\l+' "$CONNECTION_URI"
          psql -v ON_ERROR_STOP=1 -c 'show is_superuser;' "$CONNECTION_URI"
          
          pg_ctl -D /usr/local/var/postgres start || echo "pg_ctl failed"
          createuser -s postgres || echo "createuser failed"
          
          sudo -i -u postgres psql -v ON_ERROR_STOP=1 -c 'show is_superuser;' "$CONNECTION_URI"

          psql -v ON_ERROR_STOP=1 -c "CREATE EXTENSION postgis;" "$CONNECTION_URI"


#      - name: Decide Postgis version
#        # Download the list of available Postgis versions, and decide which one to use
#        id: postgis-ver
#        run: |
#          $PG_VERSION = Split-Path $env:PGROOT -Leaf
#          $postgis_page = "https://download.osgeo.org/postgis/windows/pg$PG_VERSION"
#          echo "Detecting PostGIS version from $postgis_page for PostgreSQL $PG_VERSION"
#          $pgis_bundle = (Invoke-WebRequest -Uri $postgis_page -ErrorAction Stop).Links.Where({$_.href -match "^postgis.*zip$"}).href
#          if (!$pgis_bundle) {
#            Write-Error "Could not find latest PostGIS version in $postgis_page that would match  ^postgis.*zip$  pattern"
#            exit 1
#          }
#          $pgis_bundle = [IO.Path]::ChangeExtension($pgis_bundle, [NullString]::Value)
#          $pgis_bundle_url = "$postgis_page/$pgis_bundle.zip"
#          Add-Content $env:GITHUB_OUTPUT "pgis_bundle=$pgis_bundle"
#          Add-Content $env:GITHUB_OUTPUT "pgis_bundle_url=$pgis_bundle_url"
#
#      - uses: actions/cache@v3
#        id: cache-downloads
#        with:
#          path: ${{ env.CACHED_DOWNLOADS }}
#          key: ${{ runner.os }}-${{ steps.postgis-ver.outputs.pgis_bundle_url }}
#
#      - name: Download Postgis
#        if: steps.postgis-ver.outputs.cache-hit != 'true'
#        # Download Postgis bundle if not in cache
#        env:
#          PGIS_BUNDLE: ${{ steps.postgis-ver.outputs.pgis_bundle }}
#          PGIS_BUNDLE_URL: ${{ steps.postgis-ver.outputs.pgis_bundle_url }}
#        run: |
#          echo "Downloading $env:PGIS_BUNDLE from $env:PGIS_BUNDLE_URL"
#          $postgis_zip = "postgis.zip"
#          Invoke-WebRequest $env:PGIS_BUNDLE_URL -OutFile $postgis_zip -ErrorAction Stop
#
#          echo "Extracting $env:CACHED_DOWNLOADS\$env:PGIS_BUNDLE\*"
#          Remove-Item $env:CACHED_DOWNLOADS -Force -ErrorAction SilentlyContinue
#          echo "Expanded $((Expand-Archive $postgis_zip -DestinationPath $env:CACHED_DOWNLOADS -PassThru).count) files from $postgis_zip"
#          echo "Moved $((Move-Item -Path "$env:CACHED_DOWNLOADS\$env:PGIS_BUNDLE\*" -Destination $env:CACHED_DOWNLOADS -Force -PassThru).count) files to $env:CACHED_DOWNLOADS"
#          Remove-Item $postgis_zip
#          if (!(Test-Path "$env:CACHED_DOWNLOADS\*")) {
#            Write-Error "Could not find PostGIS files in $env:CACHED_DOWNLOADS"
#            exit 1
#          }
#
#      - name: Install Postgis
#        run: |
#          if (!(Test-Path "$env:CACHED_DOWNLOADS\*")) {
#            Write-Error "Could not find PostGIS files in $env:CACHED_DOWNLOADS"
#            exit 1
#          }
#          echo "Copied $((Copy-Item -Path "$env:CACHED_DOWNLOADS\*" -Destination $env:PGROOT -Force -Recurse -PassThru).count) PostGIS files to $env:PGROOT"
#          echo "Starting PostgreSQL and adding postgis extension"
#          $env:Path = "$env:PGBIN;" + $env:Path
#          & pg_ctl restart -D "$env:PGDATA"
#          & pg_isready
#          & psql -v ON_ERROR_STOP=1 -c "select version();"
#          & psql -v ON_ERROR_STOP=1 -c "CREATE EXTENSION postgis;"
